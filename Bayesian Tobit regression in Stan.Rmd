---
title: "Bayesian Quantile Tobit regression in Stan"
author: "Miao Cai"
date: "12/23/2018"
output:
  html_document:
    theme: yeti
    toc: true
    toc_float: true
    number_sections: true
    df_print: paged
    code_folding: hide
  pdf_document:
    number_sections: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval =FALSE, cache = TRUE)
```

You need the following packages to run this Rmarkdown file:

- `tidyverse`
- `rstan`
- `brms`
- `shinystan`

# Overview

$$TE = \mathbf{X^{\prime}\beta} + \epsilon \\
\epsilon \sim N(0, \sigma^2)$$

The outcome variable is Technical efficiency (TE). It is assumed to be right-censored at 1. I didn't assume it to be interval-censored since the minimum TE value in your data is more than 0, so no data is left-censored although it could be left-censored theoretically.

The explanatory variables are:

1. bed, 
2. occ, 
3. alos, 
4. dnr, 
5. bnr, 
6. oir, 
7. pop, 
8. urban, 
9. HHI_beds, 
10. gdp

```{r DATA}
library(brms)
library(tidyverse)
library(shinystan)

dat = haven::read_dta("data/dat.dta")

dat$censoring = 0
dat$censoring[dat$TE == 1] = 1

dat1 = dat %>% 
  select(year, id, TE, censoring, bed, occ, alos, dnr, bnr, oir, pop, urban, HHI_beds, gdp) %>% 
  mutate_all(as.numeric)

isFALSE <- function (x) identical(FALSE, x)
```

# Bayesian Tobit regression

## Fixed-effects Bayesian Tobit regression

```{r tobit}
fit1 = brm(
  TE|cens(censoring) ~ bed + occ + alos + dnr + bnr + oir + pop + urban + HHI_beds + gdp, 
  family = gaussian, data = dat1, 
  inits = "0", seed = 666, cores = 4,
  chains = 4, iter = 4000, warmup = 2000)

summary(fit1)
save(fit1, file = "fit/fit1.Rdata")
# You can get a matrix of fixef effects coefficients by: 
# fixef(fit1)
readr::write_csv(fixef(fit1), "fit/Fixed-effects Bayesian Tobit regression.csv")

# shinystan::launch_shinystan(fit1)
```

## Bayesian Tobit regression with hospital and year random effects

```{r tobitrandom}
fit2 = brm(
  TE|cens(censoring) ~ bed + occ + alos + dnr + bnr + oir + pop + urban + HHI_beds + gdp + (1|id) + (1|year), 
  family = gaussian, data = dat1, 
  inits = "0", seed = 666, cores = 4,
  chains = 4, iter = 4000, warmup = 2000
)

summary(fit2)
save(fit2, file = "fit/fit2.Rdata")
readr::write_csv(fixef(fit2), "fit/Bayesian Tobit random effects.csv")
```

A few notes:

- If you want to study the underlying `Stan` codes, you can access them by `stancode(fit2)`.
- If you want to access the priors for this model, you can get them by `get_prior(TE|cens(censoring) ~ bed + occ + alos + dnr + bnr + oir + pop + urban + HHI_beds + gdp + (1|id) + (1|year), family = gaussian, 
  data = dat1)`
- You can use `shinystan::launch_shinystan(fit2)` to explore the posterior  estimates.




# Bayesian quantile Tobit regression

```{r quantiletobit}
qfit0 = brm(
  bf(TE|cens(censoring) ~ bed + occ + alos + dnr + bnr + oir + pop + urban + HHI_beds + gdp + (1|id) + (1|year), quantile = 0.2), 
  family = asym_laplace(), data = dat1, 
  inits = "0", seed = 666, control = list(max_treedepth = 15), 
  chains = 1, iter = 4000, warmup = 2000
)

save(qfit0, file = "fit/qfit0.Rdata")
readr::write_csv(fixef(qfit0), "fit/Bayesian Quantile Tobit random effects02.csv")

summary(qfit0)

# You can get a matrix of fixef effects coefficients by: 
# fixef(qfit0)

# shinystan::launch_shinystan(qfit0)
```






```{r}
for (i in 1:10) {
  zz = data.frame(x = 0.1*i)
  
  save(assign(paste0("zz", i), zz), file = paste0("fit/quantiletobit", i*0.1, ".Rdata"))
  readr::write_csv(zz, file = file = paste0("fit/quantiletobit", i*0.1, ".csv"))
}
```






















































































































































































































































































































































































```{r ARCHIVEDtobitstan, eval=FALSE, echo = FALSE}
# DON'T RUN THIS CHUNK!!
tobitstan = '
data {
  int<lower=0>  N0;        
  int<lower=0>  N1;        
  vector<lower=0,upper=1>[N0] Y0;  
  vector<lower=0,upper=1>[N1] Y1;  
  
  vector[N0] bed0;
  vector[N0] occ0;
  vector[N0] alos0;
  vector[N0] dnr0;
  vector[N0] bnr0;
  vector[N0] oir0;
  vector[N0] pop0;
  vector[N0] urban0;
  vector[N0] HHI_beds0;
  vector[N0] gdp0;

  vector[N1] bed1;
  vector[N1] occ1;
  vector[N1] alos1;
  vector[N1] dnr1;
  vector[N1] bnr1;
  vector[N1] oir1;
  vector[N1] pop1;
  vector[N1] urban1;
  vector[N1] HHI_beds1;
  vector[N1] gdp1;
}
parameters{
  real b0;
  real b1;
  real b2;
  real b3;
  real b4;
  real b5;
  real b6;
  real b7;
  real b8;
  real b9;
  real b10;
  real<lower=0> sigma;
}
model{
  Y0 ~ normal( b0 + b1*bed0 + b2*occ0 + b3*alos0 + b4*dnr0 + b5*bnr0 + b6*oir0 + b7*pop0 + b8*urban0 + b9*HHI_beds0 + b10*gdp0, sigma);
  
  target += normal_lccdf( Y1 | b1*bed1 + b2*occ1 + b3*alos1 + b4*dnr1 + b5*bnr1 + b6*oir1 + b7*pop1 + b8*urban1 + b9*HHI_beds1 + b10*gdp1, sigma );
  
  
  //PRIORS
  b0 ~ normal(0, 10);
  b1 ~ normal(0, 10);
  b2 ~ normal(0, 10);
  b3 ~ normal(0, 10);
  b4 ~ normal(0, 10);
  b5 ~ normal(0, 10);
  b6 ~ normal(0, 10);
  b7 ~ normal(0, 10);
  b8 ~ normal(0, 10);
  b9 ~ normal(0, 10);
  b10 ~ normal(0, 10);
  sigma ~ gamma(1, 1);
}
'

library(rstan)
options(mc.cores = parallel::detectCores())

dat = haven::read_dta("data/dat.dta")
datC  = dat[dat$TE == 1,]
datUN = dat[dat$TE != 1,]

scale1 = function(x) return((x - mean(x))/sd(x))

tdat1 = list(
  N0 = nrow(datUN),
  Y0 = datUN$TE,
  bed0 = scale1(datUN$bed),
  occ0 = scale1(datUN$occ),
  alos0 = scale1(datUN$alos),
  dnr0 = scale1(datUN$dnr), 
  bnr0 = scale1(datUN$bnr),
  oir0 = scale1(datUN$oir),
  pop0 = scale1(datUN$pop),
  urban0 = scale1(datUN$urban),
  HHI_beds0 = scale1(datUN$HHI_beds),
  gdp0 = scale1(datUN$gdp),
  N1 = nrow(datC),
  Y1 = datC$TE,
  bed1 = scale1(datC$bed),
  occ1 = scale1(datC$occ),
  alos1 = scale1(datC$alos),
  dnr1 = scale1(datC$dnr), 
  bnr1 = scale1(datC$bnr),
  oir1 = scale1(datC$oir),
  pop1 = scale1(datC$pop),
  urban1 = scale1(datC$urban),
  HHI_beds1 = scale1(datC$HHI_beds),
  gdp1 = scale1(datC$gdp)
)

# UNCOMMENT THE FOLLOWING LINE TO RUN
#rats_fit <- stan(model_code=tobitstan, model_name="Bayesian Tobit", data=tdat1, iter=5000,warmup = 2500, chains=1, seed = 111) # You need to RESCALE back the parameters since I have scale the data 

rstan::summary(rats_fit)
shinystan::launch_shinystan(rats_fit)
```
